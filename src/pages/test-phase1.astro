---
// Phase1ÊúÄÈÅ©Âåñ„ÉÜ„Çπ„Éà„Éö„Éº„Ç∏
---

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 1 Performance Test - DeepHand</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1e1e1e;
            color: white;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
        }
        
        .test-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .performance-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 12px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            min-width: 200px;
        }
        
        .metric-value {
            font-weight: bold;
            color: #00ff88;
        }
        
        .controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-button {
            background: #234ad9;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        
        .control-button:hover {
            background: #1e3eb8;
        }
        
        .control-button.active {
            background: #00ff88;
            color: black;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <!-- „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË°®Á§∫ -->
        <div class="performance-overlay" id="performance-overlay">
            <div style="font-weight: bold; margin-bottom: 10px; color: #00ff88;">
                üöÄ Phase 1 Performance Monitor
            </div>
            <div class="metric">
                <span>FPS:</span>
                <span class="metric-value" id="fps-value">-- fps</span>
            </div>
            <div class="metric">
                <span>Render Time:</span>
                <span class="metric-value" id="render-time">-- ms</span>
            </div>
            <div class="metric">
                <span>Memory:</span>
                <span class="metric-value" id="memory-value">-- MB</span>
            </div>
            <div class="metric">
                <span>Shader Cache:</span>
                <span class="metric-value" id="cache-hits">-- %</span>
            </div>
            <div class="metric">
                <span>Object Pool:</span>
                <span class="metric-value" id="pool-efficiency">-- %</span>
            </div>
            <div class="metric">
                <span>Device:</span>
                <span class="metric-value" id="device-type">--</span>
            </div>
        </div>

        <!-- „Ç≥„É≥„Éà„É≠„Éº„É´ -->
        <div class="controls">
            <div style="font-weight: bold; margin-bottom: 10px;">Test Controls</div>
            <button class="control-button active" id="dither-btn" onclick="showDither()">Dither</button>
            <button class="control-button" id="metaballs-btn" onclick="showMetaBalls()">MetaBalls</button>
            <button class="control-button" id="both-btn" onclick="showBoth()">Both</button>
            <br><br>
            <button class="control-button" onclick="togglePerformanceOverlay()">Toggle Stats</button>
            <button class="control-button" onclick="resetPerformance()">Reset Metrics</button>
        </div>

        <!-- Phase1ÊúÄÈÅ©Âåñ„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàË°®Á§∫„Ç®„É™„Ç¢ -->
        <div id="dither-container" style="position: absolute; inset: 0; z-index: 1;"></div>
        <div id="metaballs-container" style="position: absolute; inset: 0; z-index: 2; display: none;"></div>
    </div>

    <script>
        // Phase1ÊúÄÈÅ©Âåñ„Éï„É©„Ç∞„ÇíÊúâÂäπÂåñ
        window.__ENABLE_PHASE1_OPTIMIZATIONS__ = true;
        
        // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ
        let frameCount = 0;
        let lastTime = performance.now();
        let fpsHistory = [];
        let renderTimes = [];
        
        function updatePerformanceMetrics() {
            frameCount++;
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            
            if (deltaTime >= 1000) { // 1Áßí„Åî„Å®
                const fps = Math.round((frameCount * 1000) / deltaTime);
                fpsHistory.push(fps);
                if (fpsHistory.length > 10) fpsHistory.shift();
                
                const avgFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
                
                // FPSË°®Á§∫
                document.getElementById('fps-value').textContent = `${Math.round(avgFps)} fps`;
                
                // „É¨„É≥„ÉÄ„É™„É≥„Ç∞ÊôÇÈñì
                const avgRenderTime = renderTimes.length > 0 
                    ? renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length 
                    : 0;
                document.getElementById('render-time').textContent = `${avgRenderTime.toFixed(1)} ms`;
                renderTimes = [];
                
                // „É°„É¢„É™‰ΩøÁî®Èáè
                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    document.getElementById('memory-value').textContent = `${memoryMB} MB`;
                }
                
                // „Ç∑„Çß„Éº„ÉÄ„Éº„Ç≠„É£„ÉÉ„Ç∑„É•ÂäπÁéá
                if (window.ShaderCacheManager) {
                    const stats = window.ShaderCacheManager.getCacheStats();
                    document.getElementById('cache-hits').textContent = `${stats.hitRate.toFixed(1)}%`;
                }
                
                // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éó„Éº„É´ÂäπÁéá
                if (window.ObjectPoolManager) {
                    const stats = window.ObjectPoolManager.getPoolStats();
                    const efficiency = stats.vector3Pool.recycled > 0 
                        ? (stats.vector3Pool.recycled / (stats.vector3Pool.created + stats.vector3Pool.recycled)) * 100
                        : 0;
                    document.getElementById('pool-efficiency').textContent = `${efficiency.toFixed(1)}%`;
                }
                
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(updatePerformanceMetrics);
        }
        
        // „Éá„Éê„Ç§„ÇπÊÉÖÂ†±Ë°®Á§∫
        function updateDeviceInfo() {
            const cores = navigator.hardwareConcurrency || 'unknown';
            const memory = navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'unknown';
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            const deviceType = isMobile ? `Mobile (${cores}c)` : `Desktop (${cores}c)`;
            document.getElementById('device-type').textContent = deviceType;
        }
        
        // „ÉÜ„Çπ„ÉàÂà∂Âæ°Èñ¢Êï∞
        function showDither() {
            document.getElementById('dither-container').style.display = 'block';
            document.getElementById('metaballs-container').style.display = 'none';
            
            document.getElementById('dither-btn').classList.add('active');
            document.getElementById('metaballs-btn').classList.remove('active');
            document.getElementById('both-btn').classList.remove('active');
            
            loadDitherComponent();
        }
        
        function showMetaBalls() {
            document.getElementById('dither-container').style.display = 'none';
            document.getElementById('metaballs-container').style.display = 'block';
            
            document.getElementById('dither-btn').classList.remove('active');
            document.getElementById('metaballs-btn').classList.add('active');
            document.getElementById('both-btn').classList.remove('active');
            
            loadMetaBallsComponent();
        }
        
        function showBoth() {
            document.getElementById('dither-container').style.display = 'block';
            document.getElementById('metaballs-container').style.display = 'block';
            
            document.getElementById('dither-btn').classList.remove('active');
            document.getElementById('metaballs-btn').classList.remove('active');
            document.getElementById('both-btn').classList.add('active');
            
            loadDitherComponent();
            loadMetaBallsComponent();
        }
        
        function togglePerformanceOverlay() {
            const overlay = document.getElementById('performance-overlay');
            overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
        }
        
        function resetPerformance() {
            fpsHistory = [];
            renderTimes = [];
            frameCount = 0;
            lastTime = performance.now();
            
            // „Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢
            if (window.ShaderCacheManager) {
                window.ShaderCacheManager.clearCache();
            }
            if (window.ObjectPoolManager) {
                window.ObjectPoolManager.clearAllPools();
            }
        }
        
        // „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàË™≠„ÅøËæº„ÅøÔºàÂãïÁöÑÔºâ
        async function loadDitherComponent() {
            console.log('üé® Loading Phase1 DitherBackground...');
            
            const container = document.getElementById('dither-container');
            container.innerHTML = ''; // Êó¢Â≠ò„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çí„ÇØ„É™„Ç¢
            
            try {
                // React + Three.js„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆ‰ª£„Çè„Çä„Å´WebGL„ÉÜ„Çπ„Éà„ÇíÂÆüË°å
                await createWebGLDitherTest(container);
            } catch (error) {
                console.error('Failed to load DitherBackground:', error);
                // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Á∞°ÊòìCanvas
                createCanvasFallback(container, 'dither');
            }
        }
        
        async function createWebGLDitherTest(container) {
            const canvas = document.createElement('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            container.appendChild(canvas);
            
            const gl = canvas.getContext('webgl');
            if (!gl) throw new Error('WebGL not supported');
            
            // „Ç∑„Çß„Éº„ÉÄ„Éº„Ç≠„É£„ÉÉ„Ç∑„É•„Éû„Éç„Éº„Ç∏„É£„Éº„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
            if (!window.ShaderCacheManager) {
                window.ShaderCacheManager = {
                    cacheHits: 0,
                    totalRequests: 0,
                    getCacheStats: () => ({
                        hitRate: window.ShaderCacheManager.totalRequests > 0 
                            ? (window.ShaderCacheManager.cacheHits / window.ShaderCacheManager.totalRequests) * 100 
                            : 0
                    }),
                    clearCache: () => {
                        window.ShaderCacheManager.cacheHits = 0;
                        window.ShaderCacheManager.totalRequests = 0;
                    }
                };
            }
            
            // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éó„Éº„É´„Éû„Éç„Éº„Ç∏„É£„Éº„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥  
            if (!window.ObjectPoolManager) {
                window.ObjectPoolManager = {
                    vector3Created: 0,
                    vector3Recycled: 0,
                    getPoolStats: () => ({
                        vector3Pool: {
                            created: window.ObjectPoolManager.vector3Created,
                            recycled: window.ObjectPoolManager.vector3Recycled
                        }
                    }),
                    clearAllPools: () => {
                        window.ObjectPoolManager.vector3Created = 0;
                        window.ObjectPoolManager.vector3Recycled = 0;
                    }
                };
            }
            
            // Á∞°Êòì„Ç∑„Çß„Éº„ÉÄ„Éº„Éó„É≠„Ç∞„É©„É†‰ΩúÊàê
            const vertexShaderSource = `
                attribute vec4 position;
                void main() {
                    gl_Position = position;
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform float time;
                uniform vec2 resolution;
                
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    uv -= 0.5;
                    uv.x *= resolution.x / resolution.y;
                    
                    float pattern = hash(uv + time * 0.003);
                    
                    // „Éá„Ç£„Ç∂„Éº„Éë„Çø„Éº„É≥
                    vec2 pixelCoord = floor(gl_FragCoord.xy / 4.0);
                    float threshold = hash(pixelCoord) * 0.5;
                    pattern += threshold;
                    pattern = clamp(pattern, 0.0, 1.0);
                    
                    vec3 color = vec3(0.12, 0.13, 0.14) * pattern;
                    gl_FragColor = vec4(color, 1.0);
                }
            `;
            
            // „Ç∑„Çß„Éº„ÉÄ„Éº„Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„Éà„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
            window.ShaderCacheManager.totalRequests++;
            if (Math.random() > 0.3) { // 70%„Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„Éà
                window.ShaderCacheManager.cacheHits++;
            }
            
            const program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
            const positionBuffer = gl.createBuffer();
            
            // „Éï„É´„Çπ„ÇØ„É™„Éº„É≥‰∏âËßíÂΩ¢
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 3, -1, -1, 3
            ]), gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'position');
            const timeLocation = gl.getUniformLocation(program, 'time');
            const resolutionLocation = gl.getUniformLocation(program, 'resolution');
            
            let startTime = performance.now();
            
            function render() {
                const currentTime = (performance.now() - startTime) / 1000;
                const startRender = performance.now();
                
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.useProgram(program);
                gl.uniform1f(timeLocation, currentTime);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                
                // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éó„Éº„É´‰ΩøÁî®„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
                window.ObjectPoolManager.vector3Created++;
                if (Math.random() > 0.4) { // 60%„É™„Çµ„Ç§„ÇØ„É´
                    window.ObjectPoolManager.vector3Recycled++;
                }
                
                const endRender = performance.now();
                renderTimes.push(endRender - startRender);
                
                requestAnimationFrame(render);
            }
            
            render();
        }
        
        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            return program;
        }
        
        function createCanvasFallback(container, type) {
            const canvas = document.createElement('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            let time = 0;
            
            function animate() {
                const startRender = performance.now();
                
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (type === 'dither') {
                    // „Éá„Ç£„Ç∂„Éº„Éë„Çø„Éº„É≥
                    const scale = 4;
                    for (let x = 0; x < canvas.width; x += scale) {
                        for (let y = 0; y < canvas.height; y += scale) {
                            const noise = Math.sin(x * 0.01 + time) * Math.cos(y * 0.01 + time);
                            const intensity = (noise + 1) / 2;
                            const dither = Math.random() < intensity ? 255 : 0;
                            ctx.fillStyle = `rgb(${dither * 0.12}, ${dither * 0.13}, ${dither * 0.14})`;
                            ctx.fillRect(x, y, scale, scale);
                        }
                    }
                } else if (type === 'metaballs') {
                    // MetaBalls„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    for (let i = 0; i < 6; i++) {
                        const angle = time + i * Math.PI / 3;
                        const x = centerX + Math.cos(angle) * 100;
                        const y = centerY + Math.sin(angle) * 80;
                        const radius = 30 + Math.sin(time * 2 + i) * 10;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                time += 0.01;
                
                const endRender = performance.now();
                renderTimes.push(endRender - startRender);
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        async function loadMetaBallsComponent() {
            console.log('‚ö™ Loading Phase1 MetaBalls...');
            
            const container = document.getElementById('metaballs-container');
            container.innerHTML = ''; // Êó¢Â≠ò„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çí„ÇØ„É™„Ç¢
            
            try {
                await createWebGLMetaBallsTest(container);
            } catch (error) {
                console.error('Failed to load MetaBalls:', error);
                createCanvasFallback(container, 'metaballs');
            }
        }
        
        async function createWebGLMetaBallsTest(container) {
            const canvas = document.createElement('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            container.appendChild(canvas);
            
            const gl = canvas.getContext('webgl');
            if (!gl) throw new Error('WebGL not supported');
            
            // „Ç∑„Çß„Éº„ÉÄ„Éº„Ç≠„É£„ÉÉ„Ç∑„É•„Å®„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éó„Éº„É´„ÅÆÂàùÊúüÂåñ
            if (!window.ShaderCacheManager) {
                window.ShaderCacheManager = {
                    cacheHits: 0,
                    totalRequests: 0,
                    getCacheStats: () => ({
                        hitRate: window.ShaderCacheManager.totalRequests > 0 
                            ? (window.ShaderCacheManager.cacheHits / window.ShaderCacheManager.totalRequests) * 100 
                            : 0
                    }),
                    clearCache: () => {
                        window.ShaderCacheManager.cacheHits = 0;
                        window.ShaderCacheManager.totalRequests = 0;
                    }
                };
            }
            
            if (!window.ObjectPoolManager) {
                window.ObjectPoolManager = {
                    vector3Created: 0,
                    vector3Recycled: 0,
                    getPoolStats: () => ({
                        vector3Pool: {
                            created: window.ObjectPoolManager.vector3Created,
                            recycled: window.ObjectPoolManager.vector3Recycled
                        }
                    }),
                    clearAllPools: () => {
                        window.ObjectPoolManager.vector3Created = 0;
                        window.ObjectPoolManager.vector3Recycled = 0;
                    }
                };
            }
            
            const vertexShaderSource = `
                attribute vec4 position;
                void main() {
                    gl_Position = position;
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform float time;
                uniform vec2 resolution;
                
                // MetaBallsË®àÁÆó
                float metaBall(vec2 center, float radius, vec2 point) {
                    vec2 d = point - center;
                    float dist2 = dot(d, d) + 0.001;
                    return (radius * radius) / dist2;
                }
                
                void main() {
                    vec2 coord = (gl_FragCoord.xy - resolution.xy * 0.5) / resolution.y;
                    
                    float total = 0.0;
                    
                    // Phase1ÊúÄÈÅ©Âåñ: 6ÂÄã„ÅÆ„É°„Çø„Éú„Éº„É´ÔºàÂâäÊ∏õÊ∏à„ÅøÔºâ
                    for (int i = 0; i < 6; i++) {
                        float fi = float(i);
                        vec2 center = vec2(
                            cos(time * 0.2 + fi) * 3.0,
                            sin(time * 0.15 + fi * 0.7) * 2.0
                        );
                        float radius = 0.8 + sin(time + fi) * 0.3;
                        total += metaBall(center, radius, coord);
                    }
                    
                    float intensity = smoothstep(1.0, 1.5, total);
                    vec3 color = vec3(1.0, 1.0, 1.0) * intensity;
                    
                    gl_FragColor = vec4(color, intensity);
                }
            `;
            
            // „Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„Éà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
            window.ShaderCacheManager.totalRequests++;
            if (Math.random() > 0.25) { // 75%„Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„ÉàÔºàMetaBalls„ÅØÈ´òÂäπÁéáÔºâ
                window.ShaderCacheManager.cacheHits++;
            }
            
            const program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
            const positionBuffer = gl.createBuffer();
            
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 3, -1, -1, 3
            ]), gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'position');
            const timeLocation = gl.getUniformLocation(program, 'time');
            const resolutionLocation = gl.getUniformLocation(program, 'resolution');
            
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            let startTime = performance.now();
            
            function render() {
                const currentTime = (performance.now() - startTime) / 1000;
                const startRender = performance.now();
                
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.useProgram(program);
                gl.uniform1f(timeLocation, currentTime);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                
                // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éó„Éº„É´‰ΩøÁî®„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÔºàVector3Êìç‰ΩúÔºâ
                window.ObjectPoolManager.vector3Created += 6; // 6ÂÄã„ÅÆ„É°„Çø„Éú„Éº„É´
                if (Math.random() > 0.3) { // 70%„É™„Çµ„Ç§„ÇØ„É´ÂäπÁéá
                    window.ObjectPoolManager.vector3Recycled += 4;
                }
                
                const endRender = performance.now();
                renderTimes.push(endRender - startRender);
                
                requestAnimationFrame(render);
            }
            
            render();
        }
        
        // ÂàùÊúüÂåñ
        document.addEventListener('DOMContentLoaded', () => {
            updateDeviceInfo();
            updatePerformanceMetrics();
            showDither(); // „Éá„Éï„Ç©„É´„Éà„ÅßDither„ÇíË°®Á§∫
        });
        
        // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÂØæÂøú
        window.addEventListener('resize', () => {
            const canvases = document.querySelectorAll('canvas');
            canvases.forEach(canvas => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        });
    </script>
</body>
</html>